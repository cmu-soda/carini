{
    "preds"  :  [
        "BecLeaderTerm[I][N]",
        "BecLeaderTerm[I][M]",
        "BecLeaderTerm[I][F]",
        "BecLeaderTerm[J][N]",
        "BecLeaderTerm[J][M]",
        "BecLeaderTerm[J][F]",
        "BecLeaderTerm[K][N]",
        "BecLeaderTerm[K][M]",
        "BecLeaderTerm[K][F]",
        "BecLeaderTerm[S][N]",
        "BecLeaderTerm[S][M]",
        "BecLeaderTerm[S][F]",
        "LeaderTerm[N]",
        "LeaderTerm[M]",
        "LeaderTerm[F]",
        "ClReq[I][N]",
        "ClReq[I][M]",
        "ClReq[I][F]",
        "ClReq[J][N]",
        "ClReq[J][M]",
        "ClReq[J][F]",
        "ClReq[K][N]",
        "ClReq[K][M]",
        "ClReq[K][F]",
        "ClReq[S][N]",
        "ClReq[S][M]",
        "ClReq[S][F]",
        "ActiveTerm[N]",
        "ActiveTerm[M]",
        "ActiveTerm[F]",
        "CommitTerm[N]",
        "CommitTerm[M]",
        "CommitTerm[F]",
        "Fluent2[N][M]",
        "Fluent2[M][N]",
        "Fluent2[M][F]",
        "Fluent2[F][N]",
        "CanRollback(I,J)",
        "CanRollback(I,S)",
        "CanRollback(S,J)",
        "CanRollback(I,K)",
        "CanRollback(K,J)",
        "CanRollback(K,S)",
        "CanVoteForOplog(I,J,N)",
        "CanVoteForOplog(I,S,N)",
        "CanVoteForOplog(S,J,N)",
        "CanVoteForOplog(I,K,N)",
        "CanVoteForOplog(K,J,N)",
        "CanVoteForOplog(K,S,N)",
        "CanVoteForOplog(I,J,M)",
        "CanVoteForOplog(I,S,M)",
        "CanVoteForOplog(S,J,M)",
        "CanVoteForOplog(I,K,M)",
        "CanVoteForOplog(K,J,M)",
        "CanVoteForOplog(K,S,M)",
        "CanVoteForOplog(I,J,F)",
        "CanVoteForOplog(I,S,F)",
        "CanVoteForOplog(S,J,F)",
        "CanVoteForOplog(I,K,F)",
        "CanVoteForOplog(K,J,F)",
        "CanVoteForOplog(K,S,F)",
        "(N \\in DOMAIN log[I]) => (log[I][N] = M)",

        "(N \\in DOMAIN log[I]) => (log[I][N] <= M)",
        "(N \\in DOMAIN log[I]) => (log[I][N] <= F)",
        "(F \\in DOMAIN log[I]) => (log[I][F] <= M)",
        "(N \\in DOMAIN log[I]) => (M <= log[I][N])",
        "(F \\in DOMAIN log[I]) => (M <= log[I][F])",
        "(N \\in DOMAIN log[I]) => (F <= log[I][N])",
        "(N \\in DOMAIN log[S]) => (log[S][N] <= M)",
        "(N \\in DOMAIN log[S]) => (log[S][N] <= F)",
        "(F \\in DOMAIN log[S]) => (log[S][F] <= M)",
        "(N \\in DOMAIN log[S]) => (M <= log[S][N])",
        "(F \\in DOMAIN log[S]) => (M <= log[S][F])",
        "(N \\in DOMAIN log[S]) => (F <= log[S][N])",
        "(N \\in DOMAIN log[I] /\\ M \\in DOMAIN log[I]) => (log[I][N] <= log[I][M])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[I]) => (log[I][N] <= log[I][F])",
        "(F \\in DOMAIN log[I] /\\ M \\in DOMAIN log[I]) => (log[I][F] <= log[I][M])",
        "(N \\in DOMAIN log[I] /\\ M \\in DOMAIN log[J]) => (log[I][N] <= log[J][M])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[J]) => (log[I][N] <= log[J][F])",
        "(F \\in DOMAIN log[I] /\\ M \\in DOMAIN log[J]) => (log[I][F] <= log[J][M])",
        "(N \\in DOMAIN log[I] /\\ M \\in DOMAIN log[K]) => (log[I][N] <= log[K][M])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[K]) => (log[I][N] <= log[K][F])",
        "(F \\in DOMAIN log[I] /\\ M \\in DOMAIN log[K]) => (log[I][F] <= log[K][M])",
        "(N \\in DOMAIN log[I] /\\ M \\in DOMAIN log[S]) => (log[I][N] <= log[S][M])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[S]) => (log[I][N] <= log[S][F])",
        "(F \\in DOMAIN log[I] /\\ M \\in DOMAIN log[S]) => (log[I][F] <= log[S][M])",
        "(N \\in DOMAIN log[I] /\\ N \\in DOMAIN log[J]) => (log[I][N] <= log[J][N])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[J]) => (log[I][N] <= log[J][F])",
        "(F \\in DOMAIN log[I] /\\ N \\in DOMAIN log[J]) => (log[I][F] <= log[J][N])",
        "(N \\in DOMAIN log[I] /\\ N \\in DOMAIN log[K]) => (log[I][N] <= log[K][N])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[K]) => (log[I][N] <= log[K][F])",
        "(F \\in DOMAIN log[I] /\\ N \\in DOMAIN log[K]) => (log[I][F] <= log[K][N])",
        "(N \\in DOMAIN log[I] /\\ N \\in DOMAIN log[S]) => (log[I][N] <= log[S][N])",
        "(N \\in DOMAIN log[I] /\\ F \\in DOMAIN log[S]) => (log[I][N] <= log[S][F])",
        "(F \\in DOMAIN log[I] /\\ N \\in DOMAIN log[S]) => (log[I][F] <= log[S][N])",
        "Len(log[I]) <= M",
        "Len(log[I]) <= F",
        "Len(log[I]) <= M",
        "M <= Len(log[I])",
        "M <= Len(log[I])",
        "F <= Len(log[I])",
        "Len(log[S]) <= M",
        "Len(log[S]) <= F",
        "Len(log[S]) <= M",
        "M <= Len(log[S])",
        "M <= Len(log[S])",
        "F <= Len(log[S])",
        "I = S",
        "N <= F"
    ],
    "preds_alt" : [],
    "safety"  :  "Safety",
    "constants"  : [
        "CONSTANTS" ,
        "Server = {n1,n2,n3}",
        "FinNat = {1,2,3}",
        "n1=n1",
        "n2=n2",
        "n3=n3"
    ],
    "constraint"  :  "CONSTRAINT StateConstraint",
    "quant_inv"  :  "\\A N \\in FinNat : \\A I \\in Server : \\A J \\in Server : \\E F \\in FinNat : \\E S \\in Server : \\A M \\in FinNat : \\A K \\in Server : ",
    "quant_inv_alt"  :  null,
    "quant_vars": ["I","J","N","M"],
    "model_consts"  :  "CONSTANT n1,n2,n3",
    "symmetry" : true,
    "typeok"  :  "TypeOKRand",
    "simulate"  :  true
}
