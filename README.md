# Carini

Carini (Compositionally Arranged INductive Invariants) is a tool that helps with *fully compositional* inductive invariant inference for formal specifications written in TLA+.
More specifically, Carini accepts as input two components $C_1$ and $C_2$ and a safety property $P$ with the goal of proving that $C_1 \parallel C_2 \models P$.
Carini attempts compsitional verification, i.e. it tries to find an *assumption* $A$ such that $\langle \text{True} \rangle C_1 \langle A \rangle$ and $\langle A \rangle C_2 \langle P \rangle$.
The notation $\langle \alpha \rangle C \langle \gamma \rangle$ indicates an *assume-guarantee contract*, meaning that the component $C$ guarantees $\gamma$ under the assumption $\alpha$.

If Carini succeeds, it will output a "_hist" TLA+ specification for each component, which represents the contract for each component.
Then, any off-the-shelf invariant inference tool can be used to find a *local inductive invariant* for the two _hist specifications.
For example, one can use the [Endive](https://github.com/will62794/endive) tool for local invariant inference.
By construction, the conjunction of the two local invariants is an inductive invariant that proves $C_1 \parallel C_2 \models P$.


## Installation
For convenience, we have prebuilt carini.jar (located in the [bin](https://github.com/cmu-soda/carini/tree/master/bin) folder).
However, Carini has two dependencies that require a slightly odd (but simple) set up:
- TLC.
  Carini requires TLC to be installed on your system, which you can get from [here](https://github.com/tlaplus/tlaplus/releases).
  Carini expects TLC to be installed under a bin folder in your home directory with the name tla2tools.jar.
  For example, on a Unix system, TLC should be installed at ~/bin/tla2tools.jar
- Formula synthesis.
  Carini requires installing the [alsm-formula-synth tool](https://github.com/iandardik/alsm-formula-synthesis).
  To install this tool, simply git clone it onto your machine.
  Then, Carini requires you to set the environment variable ALSM_FORMULA_SYNTH to the path where you installed the alsm-formula-synth repo.
  For example, if you do a 'git clone' to install alsm-formula-synth from the directory /path/to/dir, then on a Unix system you can do
  ``export ALSM_FORMULA_SYNTH='/path/to/dir/alsm-formula-synthesis``.

Carini has been tested with Java 18 on both MacOS and Linux systems.


## Usage

usage: ``carini <tlaComp> <cfgComp> <tlaRest> <cfgRest> <propFile>``
- tlaComp: a TLA+ file (.tla) that specifies the component $C_2$ as well as the property $P$.
- cfgComp: a config file (.cfg) for the component $C_2$. The config should include the invariant $P$ if it is a TLA+ invariant; if $P$ is an assumption, however, then the config should not include any invariants or properties; in this case, $P$ will be included in the propFile.
- tlaRest: a TLA+ file (.tla) that specifies the component $C_1$. The reason the parameter is called "rest" is because $C_1$ may be the composition of other components (see the 2PC example below).
- cfgRest: a config file (.cfg) for the component $C_1$. The config should not include any invariants or properties.
- propFile: an assumption property file (.inv) that describes $P$ when it is an assumption previously generated by Carini.


## Two Phase Commit (2PC) Example

We include three examples in the case_studies folder.
We will demonstrate using Carini from the command line (on a Unix-based system) to verify the 2PC example here.

To view the 2PC example, ``cd case_studies/two_phase/verification``.
There are three components for the 2PC protocol: $RM$, $Env$, and $TM$.
Our goal is to use Carini to generate two assumptions: $A_1$ (for $RM$) and $A_2$ (for $Env$).
Once we have the two assumptions, we can use an off-the-shelf inductive invariant inference tool to find a local inductive invariant for each component.

We begin by using Carini to infer $A_1$.
We use Carini to find $A_1$ such that $\langle \text{True} \rangle TM \parallel Env \langle A_1 \rangle$ and $\langle A_1 \rangle RM \langle Consistent \rangle$.
This can be performed by running the shell script [run_RM.sh](https://github.com/cmu-soda/carini/blob/master/case_studies/two_phase/verification/run_RM.sh).
Notice that the shell script uses "none" for the propFile; this will be the case the first time Carini is run in an example, since the property $P$ (in this case $Consistent$) is specified as a TLA+ invariant.

After running run_RM.sh, Carini will create several files, including RM_hist.tla, EnvTM_hist.tla, and RM.inv.
We will discuss the _hist files later when we are interested in finding local invariants.
RM.inv represents the assumption $A_1$ that we will use next to infer $A_2$.

Next, we use Carini to find an $A_2$ such that $\langle \text{True} \rangle TM \langle A_2 \rangle$ and $\langle A_2 \rangle Env \langle A_1 \rangle$.
This can be performed by running the shell script [run_Env.sh](https://github.com/cmu-soda/carini/blob/master/case_studies/two_phase/verification/run_Env.sh).
Notice that the shell script uses RM.inv for the propFile to represent the previous assumption $A_1$ (also notice that Env.tla uses no_invs.cfg which does not specify an invariant).

After running run_Env.sh, Carini creates several files, including Env_hist.tla, TM_hist.tla, and Env.inv.
At this point, Carini has inferred both $A_1$ and $A_2$ so we can now move on to local invariant inference.

The final step is to infer local inductive invariants that prove that the three contracts $\langle \text{True} \rangle TM \langle A_2 \rangle$, $\langle A_2 \rangle Env \langle A_1 \rangle$, and $\langle A_1 \rangle RM \langle Consistent \rangle$ are valid.
To prove the first contract valid, we must verify that TM_hist $\models$ TM_hist!CandSep (Carini automatically generates TM_hist!CandSep).
To prove the second contract valid, we must verify that Env_hist $\models$ Env_hist!CandSep (also automatically generated by Carini).
Finally, to prove the third contract valid, we must verify that RM_hist $\models Consistent$.
These three verification tasks can be accomplished with an off-the-shelf invariant inference tool such as [Endive](https://github.com/will62794/endive).
Once a local inductive invariant is found for each of the three contracts, the conjunction of all three local invariants is a global inductive invariant that proves the entire 2PC protocol to be correct!
